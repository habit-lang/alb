{-# LANGUAGE FlexibleInstances #-}
module Solver.Syntax (module Solver.Syntax, Kind(..), Kinded(..), Id(..), Location(..), toId, fromId, freshPrefix, fromString, kind) where

import Data.Maybe (fromMaybe)
import Syntax.Common (Kind(..), Kinded(..), Location(..), Id(..), toId, fromId, freshPrefix, fromString, kind)
import qualified Syntax.IMPEG.KSubst as K

concatMapM f xs = concat `fmap` mapM f xs

----------------------------------------------------------------------------------------------------
-- AST

infixl 5 :@
type TyId = Kinded Id
data Type = TyCon TyId  | TyVar TyId | TyGen Int | TyLit Integer | Type :@ Type deriving (Eq, Show)

kindOf                     :: Type -> Kind
kindOf (TyCon (Kinded _ k)) = k
kindOf (TyVar (Kinded _ k)) = k
kindOf (TyGen _)            = error "Solver.Syntax:16"
kindOf (TyLit _)            = KNat
kindOf (t :@ t')            =
    case kindOf t of
      KFun _ result -> result
      KVar v        -> KVar v -- bogus (included because the ilab parser doesn't understand kinds)
      _             -> error "Solver.Syntax:21"

data Flag = Inc | Exc deriving (Eq, Read, Show)
data Pred = Pred Id [Type] Flag Location deriving (Show)

instance Eq Pred  -- a version of equality that ignores locations
    where Pred cl ts x _ == Pred cl' ts' x' _ = cl == cl' && ts == ts' && x == x'

data Qual t = [Pred] :=> t deriving (Eq, Show)
type QPred  = Qual Pred

data Scheme t = Forall [Kind] t
                deriving (Eq, Show)

qPredName :: QPred -> Id
qPredName (_ :=> Pred name _ _ _) = name

data Name = UserSupplied { nameFrom :: Id }
          | AutoGenerated { nameFrom :: Id } deriving (Eq, Show)
            -- (the printer does not print AutoGenerated names)

data Axiom  = Ax { axid :: Name
                 , rules :: [Scheme QPred] }
              deriving (Eq, Show)
type Axioms = [Axiom]

data FunDep = [Int] :~> [Int] deriving (Eq, Show)
type FunDeps = [(Id, [FunDep])]   -- [(classname, fundeps)]

type PCon = PId -> Proof

-- Requirements are a generalization of superclasses in Haskell.  Examples
-- include:
--      "Num t requires Eq t, Show t"  (superclasses)
--      "x<y, y<z requires x<z"        (transitivity)
-- In these examples, the hypotheses are on the left and the conclusions
-- are on the right.
data Requirement = Requires [Pred]        -- hypotheses
                            [(PId, Pred)] -- conclusions
                   deriving (Eq, Show)

type Requirements = [Scheme Requirement]

type RequirementTemplate = ([TyId], [Pred], [Proof] -> [(Pred, PCon)])
-- A RequirementTemplate contains:
--   (type ids that you are no longer free to bind,
--    list of remaining predicates to prove,
--    function that will give complete proof from proofs of remaining preds)
-- This represents a partially applied requirement: for example, with a requirement
-- "x<y, y<z requires x<z", and given a<3, we can "derive" two new
-- requirements:  "forall z. 3<z requires a<z"   (matching a<3 against 1st hyp)
--                "forall x. x<a requires x<3"   (matching a<3 against 2nd hyp)
-- The first of these is represented by template that:
-- - fixes "a" (so "z", not included in the list, is still universally quantified)
-- - still requires "3<z"
-- - will be able to construct a proof for a<z from a proof for 3<z.

type Opacities = [(Id, [Int])]  -- [(classname, list of (numbers) for opaque parameters)]

-- Represents top level programs for ilab; not required for type inference.
type Prog = [Top]
data Top  = Query (Qual [Pred])
          | Axiom Axiom Bool       -- Boolean True signals need for greatest fixed point
                                   -- semantics; only used for derived instances.
                                   -- (Trailing "!" instead of "." in ilab syntax)
          | FunDep (Id, [FunDep])
          | Requirement (Scheme Requirement)
          | Opacity (Id, [Int])
            deriving (Eq, Show)

----------------------------------------------------------------------------------------------------
-- Abstracting flagged operations

class Flagged t
    where flag   :: t -> Flag
          invert :: t -> t

instance Flagged Flag
    where flag = id
          invert Inc = Exc
          invert Exc = Inc

instance Flagged Pred
    where flag (Pred _ _ f _) = f
          invert (Pred c ts f loc) = Pred c ts (invert f) loc

instance Flagged t => Flagged (Qual t)
    where flag (_ :=> p) = flag p
          invert (qs :=> p) = qs :=> invert p

----------------------------------------------------------------------------------------------------
-- Loop detection in proofs
--
-- The 'Contains' class implements loop detection in proofs and predicate
-- expansion.  We say that t `contains` u if u = T ... for some type constructor
-- T, and t = T ... u ...
--
-- Examples:  [t] does not contain t
--       but  [[t]] does contain [t]   (repetition of type constructor)
-- Used to limit looping for forward chaining reasoning; somewhat ad-hoc.

class Contains t
    where contains :: t -> t -> Bool

instance Contains Type
    where contains (TyCon s) (TyCon s') = s == s'
          contains (TyVar _) (TyVar _)  = True
          contains t u                  = t == u || (head ts == head us && any (u `inside`) ts)
              where ts = flatten t
                    us = flatten u

                    inside (TyVar _) (TyVar _)  = True
                    inside (TyCon s) (TyCon s') = s == s'
                    inside t u = t == u || any (t `inside`) (tail (flatten u))

                    flatten :: Type -> [Type]
                    flatten (t :@ u) = flatten t ++ [u]
                    flatten t = [t]

instance Contains t => Contains [t]
    where ts `contains` us = length ts == length us && and (zipWith contains ts us)

instance Contains Pred
    where (Pred cl ts f _) `contains` (Pred cl' ts' f' _) = (cl == cl') && (ts `contains` ts') && (f == f')

----------------------------------------------------------------------------------------------------
-- Substitutions

-- We have a somewhat odd implementation of substitutions.  In particular, when adding substitutions
-- to the trail, we associate an index with each binding (which the solver will use to identify
-- deduction steps that depended on that binding), and we do not compose items within a
-- substitution.  For example, if the trail consists of the binding:
--   1: a +-> b
-- and we add the binding b +-> c, then we will end up with the substitution
--   2: b +-> c
--   1: a +-> b
-- instead of
--   2: b +-> c
--   1: a +-> c
-- This allows us to invalidate the second line later without having to store the entire
-- substitution each time we add to it; the cost is that, when we apply a substitution to a type,
-- it is not enough to simply find the replacements for the variables in the type; we must apply
-- the portion of the substitution following each replacement to the replacement value as well.

data Binding     = TyId :-> Type
                   deriving Show
data Subst       = S K.KSubst [Binding]
                   deriving Show
data TaggedSubst = TS K.KSubst [(Int, Binding)]
                   deriving Show

-- The types in a Binding may include kind variables, and these might be instantiated during
-- unification, which is why we need a KSubst as well as a list of Bindings that represent
-- substitutions on types.

untag           :: TaggedSubst -> Subst
untag (TS ks bs) = S ks [b | (_, b) <- bs]

----------------------------------------------------------------------------------------------------
-- Proofs

type PId  = Id
data AxId = AxId PId (Maybe Int)  -- (axiom name, Just (clause number) or Nothing for an axiom with only one clause)
            deriving (Eq, Show)

type Skip = (Int, Proof)    -- (index of a disproved hypothesis, associated dis-proof)
                            -- does not contribute to semantics

data Spin = Proving | Disproving deriving (Eq, Show)
instance Flagged Spin
    where flag _ = error "Solver.Syntax:160"
          invert Proving    = Disproving
          invert Disproving = Proving

-- PAx is cheating, but I don't have a better idea yet.  The issue is that the first argument
-- identifies the proof, the second is the axiom name, and the fifth is the arguments.  The PId
-- identifier scopes over the entire (set) of proofs.  A better approach would be to only identify
-- the proofs that are used in multiple places, and then pull those to the outside as lets, but this
-- would complicate proof construction significantly, so I'm delaying until I have some strong
-- reason to figure it out.

data Proof = PAx            PId AxId [Type] [Skip] [Proof]
           | PCases         PId [(Subst, Subst, Proof)] -- [(condition, improvement, proof)]
           | PComputedCases PId [TyId] [TyId] ([Type] -> [Type]) ([Type] -> Proof)
                                                        -- see explanation of fields below.
           | PAssump        PId PId
           | PRequired      PId PId [Proof]             -- Proof node id, name of requirement, proofs for requirement hyps.
           | PClause        PId AxId [Type] [Proof]     -- Individual clauses, broken out of PAx or PCases.
           | PFrom          ProofPattern Proof Proof    -- MPEG-like, ((pattern <- proof) => proof); see below.
           | PSkip          AxId Skip
           | PExFalso                                   -- See comment below.
           | PInapplicable                              -- Used (only) in inapplicable branches of a PCases proof.
             deriving (Show)

-- PCases is used in proofs where the appropriate axiom ends with a catch all clause:
--  e.g.,   C Int; C Bool; C t.

-- PComputedCases is the corresponding version of PCases for oracles.
-- e.g., given  m + n = 32,  m < 33
-- 1) proof id
-- 2) input variables (over which we will discrimate): m
-- 3) variables that can be improved: n
-- 4) mapping from instantiations of m to instantiations of n (e.g.,  [1] \mapsto [31]) 
-- 5) mapping from instantiations of m to proofs

-- PFrom is used in situations where we know that a proof will be of a particular form because
-- the associated class is defined by an axiom of the form:
--     instance pred if P where ... else pred fails

data ProofPattern = Pat AxId [Type] [PId]
                  | Wild
                    deriving Show

-- PExFalso:  How to handle the following queries:
--    Eq (a -> b) if Int = Char?
--    Eq (a -> b) if Int = (a -> b)?
-- Both results are "proved" ex falso because the hypothesis is false.
-- Mildly functional, but not sure if this mechanism is useful.  Likely
-- necessary, however, in the context of GADTs.

instance Show ([Type] -> [Type])
    where show _ = "<computed improvement>"

instance Show ([Type] -> Proof)
    where show _ = "<computed proof>"

proofName                              :: Proof -> Maybe PId
proofName (PAx name _ _ _ _)            = Just name
proofName (PCases name _)               = Just name
proofName (PComputedCases name _ _ _ _) = Just name
proofName (PAssump name _)              = Just name
proofName (PRequired name _ _)          = Just name
proofName (PClause name _ _ _)          = Just name
proofName _                             = Nothing

assumptionsIn                    :: Proof -> [PId]
assumptionsIn (PAx _ _ _ _ ps)    = concatMap assumptionsIn ps
assumptionsIn (PCases _ ps)       = concat [assumptionsIn pr | (_, _, pr) <- ps]
assumptionsIn (PComputedCases {}) = []
assumptionsIn (PAssump _ id)      = [id]
assumptionsIn (PRequired _ _ ps)  = concatMap assumptionsIn ps
assumptionsIn (PClause _ _ _ ps)  = concatMap assumptionsIn ps
assumptionsIn (PFrom _ p p')      = assumptionsIn p ++ assumptionsIn p'
assumptionsIn (PSkip _ (_, p))    = assumptionsIn p
assumptionsIn _                   = []

definedIn                           :: Proof -> [PId]
definedIn (PAx v _ _ _ _)            = [v]
definedIn (PCases v _)               = [v]
definedIn (PComputedCases v _ _ _ _) = [v]
definedIn (PAssump v _)              = [v]
definedIn (PRequired v _ ps)         = v : concatMap definedIn ps
definedIn (PClause _ _ _ ps)         = concatMap definedIn ps
definedIn (PFrom _ _ p)              = definedIn p
definedIn (PSkip _ (_, p))           = definedIn p
definedIn _                          = []

-- A RqImpls structure caches proofs corresponding to requirements.
data RqImpls      = RqImpls [(PId, [RqImpl])]
type RqImpl       = ([ProofPattern], Proof) -- implicitly quantified over all variables appearing in the LHS

----------------------------------------------------------------------------------------------------
-- Functional dependencies

-- For a fundep X ~> Y, with additional labels Z:
--   modFD          keeps components for X, Z, and discards the components for Y
--   atDetermined      "       "         Y      "     "      "      "       "  X, Z
--   atDetermining     "       "         X      "     "      "      "       "  Y, Z

class ModFD t
    where modFD         :: t -> FunDep -> t
          atDetermined  :: t -> FunDep -> t
          atDetermining :: t -> FunDep -> t

keepIdxs ixs l = loop 0 l
    where loop _ [] = []
          loop n (x:xs) | n `elem` ixs = x : loop (n + 1) xs
                        | otherwise    = loop (n + 1) xs

instance ModFD Pred
    where Pred cl ts fl loc `modFD` (_ :~> determined) = Pred cl (dropIdxs determined ts) fl loc
              where dropIdxs ixs l = loop 0 l
                        where loop _ []                    = []
                              loop n (x:xs) | n `elem` ixs = loop (n + 1) xs
                                            | otherwise    = x : loop (n + 1) xs
          Pred cl ts fl loc `atDetermined` (_ :~> determined)   = Pred cl (keepIdxs determined ts) fl loc
          Pred cl ts fl loc `atDetermining` (determining :~> _) = Pred cl (keepIdxs determining ts) fl loc

instance {-# OVERLAPPING #-} ModFD a => ModFD (a -> b)
    where f `modFD`         fd = \a -> f (a `modFD` fd)
          f `atDetermined`  fd = \a -> f (a `atDetermined` fd)
          f `atDetermining` fd = \a -> f (a `atDetermining` fd)

instance  {-# OVERLAPPING #-} (ModFD a, ModFD b) => ModFD (a -> b -> c)
    where f `modFD`         fd = \a b -> f (a `modFD` fd) (b `modFD` fd)
          f `atDetermined`  fd = \a b -> f (a `atDetermined` fd) (b `atDetermined` fd)
          f `atDetermining` fd = \a b -> f (a `atDetermining` fd) (b `atDetermining` fd)

----------------------------------------------------------------------------------------------------
-- Conflict

-- Two predicates conflict if either one of them is the inverse of the other,
-- or else if they are predicates for the same class that directly violate one of the
-- fundeps for that class.   (See Morris, Chapter 4, ...)

conflicts :: FunDeps -> Pred -> Pred -> Bool
conflicts fds p@(Pred cl ts f _) q@(Pred cl' ts' f' _) =
    p == invert q || (cl == cl' && f == Inc && f' == Inc && any conflictsAt classFDs)
    where classFDs = fromMaybe [] (lookup cl fds)
          conflictsAt fd = ((==) `atDetermining` fd) p q && ((/=) `atDetermined` fd) p q

